/**********************************************************************/
/*           This is the podem test pattern generator for tdf atpg    */
/*                                                                    */
/*           Author: Pei-Chen(Jenny) Yen                              */
/*           last update : 06/04/2020                                 */
/**********************************************************************/
#include "atpg.h"

void ATPG::dynamic_test_compress(int &current_backtracks)
{
    fptr second_fault;
    int gen_result;
    int i;
    // vector generated by primary fault is given in the form of n+1 bits
    // the last bit represents an extra shift-in bit for LOS
    vector<int> tmp_vec = tdf_vec;
    while(true){
        tmp_vec = tdf_vec;
        // select secondary fault
        // TODO
        second_fault = get_second_fault();
        // end TODO
        // terminate dtc if no more fault to choose
        if(second_fault==nullptr) break;
        // load v2
        i = 0;
        for(wptr pi : cktin){
            if(i == 0) pi->value = tmp_vec.back();
            else pi->value = tmp_vec[i-1];
            pi->set_changed();
            i++;
        }
        sim();
        // expand v2
        gen_result = tdf_podem(second_fault, current_backtracks, false);
        if(gen_result!=TRUE) continue;
        // collect v2 on tmp_vec
        i = 0;
        for(wptr pi : cktin){
            if(i==0) tmp_vec.back() = pi->value;
            else tmp_vec[i-1] = pi->value;
            i++;
        }
        // load v1
        i = 0;
        for(wptr pi : cktin){
            pi->value = tmp_vec[i];
            pi->set_changed();
            i++;
        }
        sim();
        // expand v1
        reverse_fault_type(second_fault);
        gen_result = tdf_podem_activate(second_fault, current_backtracks, false);
        reverse_fault_type(second_fault);
        if(gen_result!=TRUE) continue;
        // collect v1 on tmp_vec
        i = 0;
        for(wptr pi : cktin){
            tmp_vec[i] = pi->value;
            i++;
        }
        tdf_vec = tmp_vec;
    }
}

// TODO
ATPG::fptr ATPG::get_second_fault()
// fptr ATPG::get_second_fault()
{
    // fault list: flist_undetect
    int i = 0;
    int j = 0;
    fptr second_fault;
    bool _fail;
    vector<int> tmp_vec = tdf_vec;

    for(fptr fault : flist_undetect){
    	_fail = false;

    	// cout<<"get faulty wire"<<endl;
    	wptr faulty_w = fault->get_faulty_wire();

    	// cout<<"load v1"<<endl;
    	// load v1
    	i = 0;
    	for(wptr pi : cktin){
        	pi->value = tmp_vec[i];
        	pi->set_changed();
        	i++;
    	}
    	// cout<<"sim v1"<<endl;
    	sim();
    	// cout<<"check conflict"<<endl;
    	_fail = conflict(fault->fault_type, faulty_w->value);
    	if(_fail)	continue;

    	// cout<<"load v2"<<endl;
		// load v2
		i = 0;
		for(wptr pi : cktin){
    		if(i == 0) pi->value = tmp_vec.back();
    		else pi->value = tmp_vec[i-1];
    		pi->set_changed();
    		i++;
		}
		// cout<<"sim v2"<<endl;
		sim();

		// cout<<"check conflict"<<endl;
		reverse_fault_type(fault);
		_fail |= conflict(fault->fault_type, faulty_w->value);
		reverse_fault_type(fault);
		if(_fail)	continue;

		// cout<<"trace x path"<<endl;
		_fail |= (!trace_unknown_path(faulty_w));
		if(_fail)	continue;

		if(_fail == false){
			second_fault = fault;
			break;
		}
    }

    if(_fail == true)
    	return nullptr;
    else
    	return second_fault;

}